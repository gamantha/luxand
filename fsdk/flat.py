#
#         Luxand FaceSDK Library
#
#  Copyright(c) 2020 Luxand, Inc.
#         http://www.luxand.com
#
#  Wrapper classes and functions for FaceSDK
#  This code is compatible with python 2 & 3 
#
###########################################

import ctypes, os, sys, inspect
from ctypes import c_int, c_uint, c_ushort, c_float, c_char, c_longlong, c_double, c_ubyte, c_wchar, c_wchar_p, c_bool, c_void_p
from ctypes import POINTER, byref, create_string_buffer
from . import const

python2 = sys.version_info.major == 2
windows = sys.platform == 'win32'
linux   = 'linux' in sys.platform
if windows:
	from ctypes import wintypes, windll
	import win
	from win import HBITMAP

	create_camera_buffer = ctypes.create_unicode_buffer
	camera_char_p = ctypes.c_wchar_p
	process_str = lambda x: x
else:
	create_camera_buffer = lambda x: ctypes.create_string_buffer(x.encode('utf-8'))
	camera_char_p = ctypes.c_char_p
	process_str = lambda x: x.decode('utf-8')

# supported platforms returned by sys.platform attribute
FSDK_LIB = {
	'win32': 'win32/facesdk.dll',
	'win64': 'win64/facesdk.dll',
	'darwin': 'osx_x86_64/libfsdk.dylib',
	'linux32': 'linux32/libfsdk.so',
	'linux64': 'linux64/libfsdk.so',
	'linux32_arm': 'linux32_arm/libfsdk.so',
	'linux64_arm': 'linux64_arm/libfsdk.so',
}

platform = sys.platform
if platform == 'win32':
	if '64 bit' in sys.version:
		platform = 'win64'
elif 'linux' in platform:
	platform = 'linux64' if sys.maxsize > 2**32 else 'linux32'
	import platform as _platform
	if 'arm' in _platform.machine():
		platform += '_arm'

if platform not in FSDK_LIB: 
	raise Exception("Unsupported platform '%s' for FaceSDK.\nMake sure your platform is specified in FSDK_LIB dictionary." % sys.platform)
fsdkDll_file_name = os.path.join(os.path.split(__file__)[0], FSDK_LIB[platform])
if not os.path.isfile(fsdkDll_file_name):  
	raise Exception("FaceSDK binary '%s' could not be found." % fsdkDll_file_name)

fsdkDll = ctypes.CDLL(fsdkDll_file_name)

ERROR_NAMES = {v:n for n,v in const.__dict__.items() if n.startswith('FSDKE_')}

# this exception class is available as FSDK.Exception
class FSDK_Exception(Exception):
	def __init__(self, func_name, error_id, desc=''):
		self.func_name, self.error_id = func_name, error_id
		msg = "%s -> %s (%s) %s" % (func_name, ERROR_NAMES.get(error_id, 'UNKNOWN ERROR'), error_id, ': ' + str(desc) if desc else '')
		if error_id == const.FSDKE_NOT_ACTIVATED: msg += '\nPlease run the License Key Wizard (Start - Luxand - FaceSDK - License Key Wizard)'
		super(FSDK_Exception, self).__init__(msg)

# exceptions generated by wrapper for particular FaceSDK error codes
class Failed(FSDK_Exception):                    "FSDKE_FAILED = -1"
class NotActivated(FSDK_Exception):              "FSDKE_NOT_ACTIVATED = -2"
class OutOfMemory(FSDK_Exception):               "FSDKE_OUT_OF_MEMORY = -3"
class InvalidArgument(FSDK_Exception):           "FSDKE_INVALID_ARGUMENT = -4"
class IOError(FSDK_Exception):                   "FSDKE_IO_ERROR = -5"
class ImageTooSmall(FSDK_Exception):             "FSDKE_IMAGE_TOO_SMALL = -6"
class FaceNotFound(FSDK_Exception):              "FSDKE_FACE_NOT_FOUND = -7"
class InsufficientBufferSize(FSDK_Exception):    "FSDKE_INSUFFICIENT_BUFFER_SIZE = -8"
class UnsupportedImageExtension(FSDK_Exception): "FSDKE_UNSUPPORTED_IMAGE_EXTENSION = -9"
class CannotOpenFile(FSDK_Exception):            "FSDKE_CANNOT_OPEN_FILE = -10"
class CannotCreateFile(FSDK_Exception):          "FSDKE_CANNOT_CREATE_FILE = -11"
class BadFileFormat(FSDK_Exception):             "FSDKE_BAD_FILE_FORMAT = -12"
class FileNotFound(FSDK_Exception):              "FSDKE_FILE_NOT_FOUND = -13"
class ConnectionClosed(FSDK_Exception):          "FSDKE_CONNECTION_CLOSED = -14"
class ConnectionFailed(FSDK_Exception):          "FSDKE_CONNECTION_FAILED = -15"
class IPInitFailed(FSDK_Exception):              "FSDKE_IP_INIT_FAILED = -16"
class NeedServerActivation(FSDK_Exception):      "FSDKE_NEED_SERVER_ACTIVATION = -17"
class IdNotFound(FSDK_Exception):                "FSDKE_ID_NOT_FOUND = -18"
class AttributeNotDetected(FSDK_Exception):      "FSDKE_ATTRIBUTE_NOT_DETECTED = -19"
class InsufficientTrackerMemoryLimit(FSDK_Exception): "FSDKE_INSUFFICIENT_TRACKER_MEMORY_LIMIT = -20"
class UnknownAttribute(FSDK_Exception):          "FSDKE_UNKNOWN_ATTRIBUTE = -21"
class UnsupportedFileVersion(FSDK_Exception):    "FSDKE_UNSUPPORTED_FILE_VERSION = -22"
class SyntaxError(FSDK_Exception):               "FSDKE_SYNTAX_ERROR = -23"
class ParameterNotFound(FSDK_Exception):         "FSDKE_PARAMETER_NOT_FOUND = -24"
class InvalidTemplate(FSDK_Exception):           "FSDKE_INVALID_TEMPLATE = -25"
class UnsupportedTemplateVersion(FSDK_Exception):"FSDKE_UNSUPPORTED_TEMPLATE_VERSION = -26"
class CameraIndexDoesNotExist(FSDK_Exception):   "FSDKE_CAMERA_INDEX_DOES_NOT_EXIST = -27"
class PlatformNotLicensed(FSDK_Exception):       "FSDKE_PLATFORM_NOT_LICENSED = -28"

def value_to_str(val):
	val = str(val)
	return val.lower() if val in ('True', 'False') else val

def cstr(s):
	return create_string_buffer(s.encode('utf-8'))

# types used in FaceSDK

class Point(ctypes.Structure):
	_fields_ = ("x", c_int), ("y", c_int)
	__repr__ = __str__ = lambda p: 'Point(x=%i, y=%i)' % (p.x, p.y)

class Eyes(Point*2):
	if python2:
		_type_ = Point*2
		_length_ = ctypes.sizeof(_type_)
	__repr__ = __str__ = lambda p: 'Eyes(%s, %s)' % (p[0], p[1])

class FacePosition(ctypes.Structure):
 	_fields_ = ("xc", c_int), ("yc", c_int), ("w", c_int), ("_padding", c_int), ("angle", c_double)
 	__repr__ = __str__ = lambda x: 'FacePosition(xc=%i, yc=%i, w=%i, angle=%.1f)' % (x.xc, x.yc, x.w, x.angle)
 	@property
 	def rect(self):	x, y, w = self.xc, self.yc, self.w//2; return x-w, y-w, x+w, y+w

Features = Point*const.FSDK_FACIAL_FEATURE_COUNT
ConfidenceLevels = c_float*const.FSDK_FACIAL_FEATURE_COUNT
FaceTemplate = c_char*const.FSDK_FACE_TEMPLATE_SIZE
# the following code is needed for python2 compatibility
FaceTemplate.MatchFaces = FaceTemplate.Match = lambda self, face_template: FSDK.MatchFaces(self, face_template)
FaceTemplate.__name__ = 'FaceTemplate'
Features.__name__ = 'Features'

class Camera(ctypes.Structure):
	_fields_ = ("handle", c_int), # FSDK camera handle
	def __init__(self, cameraName=None): # cameraName is for windows only
		if cameraName is None: super(Camera, self).__init__(-1)
		elif isinstance(cameraName, str):
			cam = FSDK.OpenVideoCamera(cameraName)
			super(Camera, self).__init__(cam.handle)
			self.name, cam.handle = cameraName, -1
			if hasattr(cameraName, 'device_path'): self.device_path = cameraName.device_path
		else: raise InvalidArgument('Camera construction', const.FSDKE_INVALID_ARGUMENT, desc = str(cameraName))
	Close = __del__ = lambda self: FSDK.CloseVideoCamera(self) # destructor
	if windows or linux:
		def Open(self, cameraName):
			self.Close()
			cam = FSDK.OpenVideoCamera(cameraName)
			self.cam, cam.handle = cam.handle, -1
	def GrabFrame(self): return FSDK.GrabFrame(self)

if windows or linux: # windows specific classes
	class VideoFormatInfo(ctypes.Structure):
	 	_fields_ = ("Width", c_int), ("Height", c_int), ("FormatIndex", c_int)
	 	__repr__ = __str__ = lambda x: 'VideoFormatInfo(Width=%i, Height=%i, FormatIndex=%i)' % (x.Width, x.Height, x.FormatIndex)

class Image(ctypes.Structure):
	_fields_ = ("handle", c_int), # FSDK image handle (-1 means invalid or uninitialized handle)
	def __new__(cls, arg = None):
		if arg is None: return FSDK.CreateEmptyImage()
		if type(arg) is int: return super(Image, cls).__new__(cls)
		if type(arg) is str: return FSDK.LoadImageFromFile(arg)
		if windows and type(arg) is HBITMAP: return FSDK.LoadImageFromHBitmap(arg)
		raise InvalidArgument('Image construction', const.FSDKE_INVALID_ARGUMENT, desc = str(arg))
	def __init__(self, arg=None): super(Image, self).__init__(self.handle)
	Free = __del__ = lambda self: FSDK.FreeImage(self) # the function is called implicitly whenever Image is garbage collected, but can be called explicitly too
	__repr__ = __str__ = lambda x: 'Image(handle=%x)' % x.handle
	def swap(self, image): self.handle, image.handle = image.handle, self.handle; return self # swap FSDK handles of images

	width = property(lambda self: FSDK.GetImageWidth(self)) # image width
	height = property(lambda self: FSDK.GetImageHeight(self))  # image height
	size = property(lambda self: (self.width, self.height))  # image size = (width, height)

	@staticmethod
	def FromFile(fileName): return FSDK.LoadImageFromFile(fileName)
	@staticmethod
	def FromBuffer(buffer, width, height, scanLine, colorMode): return FSDK.LoadImageFromBuffer(buffer, width, height, scanLine, colorMode)
	FromBytes = FromBuffer

	def SaveToFile(self, fileName, quality = None):
		if quality: FSDK.SetJpegCompressionQuality(quality)
		FSDK.SaveImageToFile(self, fileName)

	#### Copy functions
	def Copy(self): return FSDK.CopyImage(self, Image())
	def CopyRect(self, x1, y1, x2, y2): return FSDK.CopyRect(self, x1, y1, x2, y2, Image())
	def CopyRectReplicateBorder(self, x1, y1, x2, y2): return FSDK.CopyRectReplicateBorder(self, x1, y1, x2, y2, Image())

	def Mirror(self, useVerticalMirroringInsteadOfHorizontal=False): return FSDK.MirrorImage(self, useVerticalMirroringInsteadOfHorizontal)
	def Resize(self, ratio): return FSDK.ResizeImage(self, ratio, Image())
	def ResizeXY(self, ratioX, ratioY): return FSDK.ResizeImageXY(self, ratioX, ratioY, Image())
	def Rotate90(self, multiplier = 1): return FSDK.RotateImage90(self, multiplier, Image())
	def Rotate(self, angle): return FSDK.RotateImage(self, angle, Image())
	def RotateCenter(self, angle, xc, yc): return FSDK.RotateCenter(self, angle, xc, yc, Image())
	def Crop(self, x1, y1, x2, y2): return FSDK.CopyRect(self, x1, y1, x2, y2, Image())
	def CropReplicateBorder(self, x1, y1, x2, y2): return FSDK.CopyRectReplicateBorder(self, x1, y1, x2, y2, Image())

	#### Face detection functions
	def DetectEyes(self, facePosition=None): return FSDK.DetectEyes(self) if facePosition is None else FSDK.DetectEyesInRegion(self, facePosition)
	def DetectFace(self): return FSDK.DetectFace(self)
	def DetectMultipleFaces(self): return FSDK.DetectMultipleFaces(self)
	def DetectFacialFeatures(self, facePosition=None): return FSDK.DetectFacialFeatures(self) if facePosition is None else FSDK.DetectFacialFeaturesInRegion(self, facePosition)
	def GetFaceTemplate(self, facePosition=None): return FSDK.GetFaceTemplate(self) if facePosition is None else FSDK.GetFaceTemplateInRegion(self, facePosition)
	def DetectFacialAttributeUsingFeatures(self, features, attributeName): return FSDK.DetectFacialAttributeUsingFeatures(self, features, attributeName)

	#### special functions to work with image data
	def ImageData(self): return FSDK.GetImageData(self)
	if windows:
		def GetHBitmap(self): return FSDK.SaveImageToHBitmap(self)
	def ToBuffer(self, colorMode):
		buffer = bytes(FSDK._GetImageBufferSize(self, colorMode))
		FSDK._SaveImageToBuffer(self, buffer, colorMode)
		return buffer
	ToBytes = ToBuffer

class Tracker(ctypes.Structure):
	_fields_ = ("handle", c_int), # FSDK tracker handle (-1 means invalid or uninitialized handle)
	def __new__(cls, arg = None):
		if arg is None: return FSDK.CreateTracker()
		if type(arg) is int: 
			tracker = super(Tracker, cls).__new__(cls)
			tracker.handle = -1
			return tracker
		raise InvalidArgument('Tracker construction', const.FSDKE_INVALID_ARGUMENT, desc = str(arg))
	Free = __del__ = lambda self: FSDK.FreeTracker(self)
	__repr__ = __str__ = lambda x: 'Tracker(handle=%x)' % x.handle
	def Clear(self): FSDK.ClearTracker(self)
	
	def SetParameters(self, **kw):		
		if kw: FSDK.SetTrackerMultipleParameters(self, ';'.join('%s=%s'%(n, value_to_str(v)) for n,v in kw.items()))
	def SetParameter(self, paramName, paramValue): FSDK.SetTrackerParameter(self, paramName, value_to_str(paramValue))
	def SetMultipleParameters(self, params): FSDK.SetTrackerMultipleParameters(self, params)
	def GetParameter(self, parameterName): return FSDK.GetTrackerParameter(self, parameterName)	# return parameter value
	def FeedFrame(self, cameraIdx, img, maxIDs = 256): return FSDK.FeedFrame(self, cameraIdx, img, maxIDs = maxIDs) # return array of IDs
	def GetFacePosition(self, cameraIdx, ID): return FSDK.GetTrackerFacePosition(self, cameraIdx, ID) # return FacePosition
	def GetFacialFeatures(self, cameraIdx, ID): return FSDK.GetTrackerFacialFeatures(self, cameraIdx, ID)
	def GetEyes(self, cameraIdx, ID): return FSDK.GetTrackerEyes(self, cameraIdx, ID)
	def GetFacialAttribute(self, cameraIdx, ID, attributeName): return FSDK.GetTrackerFacialAttribute(self, cameraIdx, ID, attributeName)
	GetTrackerFacialAttribute = GetFacialAttribute # for compatability with previous versions
	def LockID(self, ID): FSDK.LockID(self, ID)
	def UnlockID(self, ID): FSDK.UnlockID(self, ID)
	def PurgeID(self, ID): FSDK.PurgeID(self, ID)
	def GetName(self, ID): return FSDK.GetName(self, ID)
	def SetName(self, ID, name): FSDK.SetName(self, ID, name)
	def GetAllNames(self, ID): return FSDK.GetAllNames(self, ID)
	def GetIDReassignment(self, ID): return FSDK.GetIDReassignment(self, ID)
	def GetSimilarIDList(self, ID): return FSDK.GetSimilarIDList(self, ID)

	def SaveToFile(self, fileName): FSDK.SaveTrackerMemoryToFile(self, fileName)
	@staticmethod
	def FromFile(fileName): return FSDK.LoadTrackerMemoryFromFile(fileName)
	def GetMemory(self):
		buffer = bytes(FSDK._GetTrackerMemoryBufferSize(self))
		FSDK._SaveTrackerMemoryToBuffer(self, buffer)
		return buffer
	ToBytes = GetMemory
	@staticmethod
	def FromMemory(buffer): return FSDK.LoadTackerMemoryFromBuffer(buffer)
	FromBytes = FromMemory

# argument types by its names for type checking mechanism
arg_types = {
#	'facePosition': FacePosition,
	'eyeCoords': Eyes,
	'facialFeatures': Features,
	'tracker': Tracker,
	'camera': Camera,
	'sourceImage': Image,
	'destImage': Image,
	'image': Image,
	'faceTemplate': FaceTemplate,
	'faceTemplate1': FaceTemplate,
	'faceTemplate2': FaceTemplate,
}
if windows or linux: arg_types['videoFormat'] = VideoFormatInfo

# python2&3 base class for FSDK wrapper functions
class FSDK_Wrapper:
	# generate a dictionary that associates all error codes with their FSDK exceptions
	def get_all_fsdk_exceptions():
		import inspect
		ex = {name.upper():cls for name, cls in sys.modules[__name__].__dict__.items() if inspect.isclass(cls) and issubclass(cls, FSDK_Exception) and cls is not FSDK_Exception}
		for id, name in ERROR_NAMES.items():
			if id:
				errname = name[6:].replace("_", "")
				if errname in ex: yield (id, ex[errname])
				else: raise Exception("Failed to locate FSDK exception for error %s" % name)
				del ex[errname]
		if ex:
			raise Exception("Found exception class(es) without error code:\n%s" % '\n'.join('class ' + cls.__name__ for cls in ex.values()))
	FSDKErrors = dict(get_all_fsdk_exceptions())
	del get_all_fsdk_exceptions
	__type_checking = True
	def disable_type_checking(self): __type_checking = False
	def enable_type_checking(self): __type_checking = True

	@staticmethod
	def prepare(dct):
		def get_key_wrapper(key, func):
			a_names = inspect.getargspec(func).args[1:]
			a_types = {ind: arg_types[pname] for ind, pname in enumerate(a_names) if pname in arg_types}
			try:
				fsdkFunc = getattr(fsdkDll, key)
			except AttributeError as ex:
				if not func.__doc__.startswith("FSDK_ver"):
					raise ex
				def missed_function(message):
					def error(*v, **kw):
						raise Exception(message)
					return error
				fsdkFunc = missed_function("The function '%s' requires FaceSDK version %s or later" % (key, func.__doc__.split()[1]))

			def fsdk_wrapper(self, *arg, **kw):
				def fsdk_caller(*arg, **kw):
					if FSDK_Wrapper.__type_checking:
						for ind, req_type in a_types.items():
							if type(arg[ind]) is not req_type:
								self._lastErrorID = const.FSDKE_INVALID_ARGUMENT
								self._lastError = InvalidArgument(key, self._lastErrorID, 
									"type(%s) must be '%s', not '%s'" % (a_names[ind], req_type.__name__, type(arg[ind]).__name__))
								raise self._lastError
					self._lastErrorID = res = fsdkFunc(*arg)
					if res:
						err_desc = kw.get('err_desc', '') if kw else ''
						if inspect.isfunction(err_desc): err_desc = err_desc()
						self._lastError = FSDK_Wrapper.FSDKErrors.get(res, FSDK_Exception)(key, res, err_desc)
						if kw and kw.get('skip') in {res, all}: return None
						raise self._lastError
					self._lastError = None
					return True
				return func(fsdk_caller, *arg, **kw)
			return fsdk_wrapper

		# generate callable FSDK functions
		items = tuple((k,v) for k, v in dct.items() if inspect.isfunction(v) and not k.startswith('__'))
		for name, func in items:
			params = tuple(inspect.signature(func).parameters.keys())
			if (params and params[0] == 'f') or (inspect.getdoc(func) or "").startswith("FSDK_ver"): 
				prefix = 'FSDK' if name[0]=='_' else 'FSDK_'
				dct[name] = get_key_wrapper(prefix + name, func)

		# copy constants from const.py module to this class
		dct.update((item, getattr(const, item)) for item in dir(const) if not item.startswith('__'))
		# copy constants from const.py module to this class with removed FSDK_, FSDKE_ and FSDKP_ prefixes
		dct.update((item[item.find('_')+1:], getattr(const, item)) for item in dir(const) if item.startswith('FSDK'))

		# copy base and windows specific types to this class
		items = Image, Point, FacePosition, Eyes, Camera, FaceTemplate, Features, Tracker
		if windows: 
			items += (win.HBITMAP, VideoFormatInfo)
		dct.update((cls.__name__, cls) for cls in items)

		# make FSDK_Exception to be FSDK.Exception (inside the FSDK object)
		dct['Exception'] = FSDK_Exception
		# copy all FSDK exception classes to the FSDK object
		for ex in FSDK_Wrapper.FSDKErrors.values(): dct[ex.__name__] = ex

# decorator for new functions of new versions of FaceSDK
def FSDK_ver(ver):
	def wrapper(f):
		def caller(*args, **kw): f(*args, **kw)
		setattr(caller, "__doc__", "FSDK_ver %s" % ver)
		return caller
	return wrapper

# class for definition of FaceSDK wrapper functions
class FSDK_Class(FSDK_Wrapper):
	_lastErrorID = const.FSDKE_OK
	_lastError = None # the last FSDK_Exception object
	_char_buffer = (c_char*4096)() # internal buffer used to exchange data with external __cdecl functions

	@classmethod
	def _receive_string(cls, func):
		while 1:
			try: func(cls._char_buffer); return cls._char_buffer.value.decode('utf-8')
			except InsufficientBufferSize: cls._char_buffer = (c_char*(2*len(cls._char_buffer)))()

	##### Initialization functions #####
	def ActivateLibrary(f, licenseKey): f(cstr(licenseKey))
	def GetHardware_ID(f): f(FSDK_Class._char_buffer); return FSDK_Class._char_buffer.value.decode('utf-8')
	def GetLicenseInfo(f): f(FSDK_Class._char_buffer); return FSDK_Class._char_buffer.value.decode('utf-8')
	def GetNumThreads(f): i = c_int(); f(byref(i)); return i.value
	def SetNumThreads(f, num): f(c_int(num))
	def Initialize(f, dataFilesPath=''): f(cstr(dataFilesPath))
	def Finalize(f): f()

	##### Face detection functions (available in Image class) #####
	def DetectEyes(f, image): eyes=Eyes(); f(image, byref(eyes)); return eyes
	def DetectEyesInRegion(f, image, facePosition): eyes=Eyes(); f(image, byref(facePosition), byref(eyes)); return eyes
	def DetectFace(f, image): fp=FacePosition(); f(image, byref(fp)); return fp
	def DetectMultipleFaces(f, image):
		max_faces, cnt = 256, c_int()
		while 1:
			fp = (FacePosition*max_faces)()
			if not f(image, byref(cnt), fp, ctypes.sizeof(fp), skip=const.FSDKE_FACE_NOT_FOUND): return ()
			if cnt.value < max_faces: return fp[:cnt.value]
			max_faces *= 2
	def DetectFacialFeatures(f, image, confidenceLevels = False):
		if confidenceLevels: return FSDK.DetectFacialFeaturesEx(image)
		ff = Features(); f(image, byref(ff)); return ff
	def DetectFacialFeaturesInRegion(f, image, facePosition, confidenceLevels = False):
		if confidenceLevels: return FSDK.DetectFacialFeaturesEx(image, byref(facePosition))
		ff = Features(); f(image, byref(facePosition), byref(ff)); return ff
	def DetectFacialFeaturesEx(f, image): ff = Features(); ff.confidenceLevels = ConfidenceLevels(); f(image, byref(ff), byref(ff.confidenceLevels)); return ff
	def DetectFacialFeaturesInRegionEx(f, image, facePosition): ff = Features(); ff.confidenceLevels = ConfidenceLevels(); f(image, byref(facePosition), byref(ff), byref(ff.confidenceLevels)); return ff
	def SetFaceDetectionParameters(f, handleArbitraryRotations, determineFaceRotationAngle, internalResizeWidth):
		f(c_bool(handleArbitraryRotations), c_bool(determineFaceRotationAngle), c_int(internalResizeWidth))
	def SetFaceDetectionThreshold(f, threshold): f(c_int(threshold))
	def GetDetectedFaceConfidence(f): i = c_int(); f(byref(i)); return i.value

	##### Image manipulation functions (available in Image class) #####
	def CreateEmptyImage(f): img = Image(-1); f(byref(img)); return img
	if windows:
		def LoadImageFromFileW(f, fileName): img = Image(-1); f(byref(img), ctypes.create_unicode_buffer(fileName), err_desc = fileName); return img
		def SaveImageToFileW(f, image, fileName): f(image, ctypes.create_unicode_buffer(fileName), err_desc = fileName)
		LoadImageFromFile = lambda *x: FSDK_Class.LoadImageFromFileW(*x)
		SaveImageToFile = lambda *x: FSDK_Class.SaveImageToFileW(*x)
		def LoadImageFromHBitmap(f, bitmapHandle): img = Image(-1); f(byref(img), bitmapHandle); return img
		def SaveImageToHBitmap(f, image): bitmapHandle = HBITMAP(); f(image, byref(bitmapHandle)); return bitmapHandle
	else: # not windows
		def LoadImageFromFile(f, fileName): img = Image(-1); f(byref(img), cstr(fileName), err_desc = fileName); return img
		def SaveImageToFile(f, image, fileName): f(image, cstr(fileName), err_desc = fileName)
	def LoadImageFromBuffer(f, buffer, width, height, scanLine, imageMode): img = Image(-1); f(byref(img), buffer, c_int(width), c_int(height), c_int(scanLine), c_int(imageMode)); return img
	def LoadImageFromJpegBuffer(f, buffer, bufferLength=None): img = Image(-1); f(byref(img), buffer, c_uint(bufferLength or len(buffer))); return img
	def LoadImageFromPngBuffer(f, buffer, bufferLength=None): img = Image(-1); f(byref(img), buffer, c_uint(bufferLength or len(buffer))); return img
	def FreeImage(f, image):
		if image.handle != -1: f(image); image.handle = -1
	if True: # use Image.GetBuffer() instead of these two FSDK functions
		def _GetImageBufferSize(f, image, imageMode): i = c_int(); f(image, byref(i), c_int(imageMode)); return i.value
		def _SaveImageToBuffer(f, image, buffer, imageMode): f(image, buffer, c_int(imageMode))
	def SetJpegCompressionQuality(f, quality): f(c_int(quality))
	def CopyImage(f, sourceImage, destImage): f(sourceImage, destImage); return destImage
	def ResizeImage(f, sourceImage, ratio, destImage): f(sourceImage, c_double(ratio), destImage); return destImage
	def ResizeImageXY(f, sourceImage, ratioX, ratioY, destImage): f(sourceImage, c_double(ratioX), c_double(ratioY), destImage); return destImage
	def RotateImage90(f, sourceImage, multiplier, destImage): f(sourceImage, c_int(multiplier), destImage); return destImage
	def RotateImage(f, sourceImage, angle, destImage): f(sourceImage, c_double(angle), destImage); return destImage
	def RotateImageCenter(f, sourceImage, angle, xCenter, yCenter, destImage): f(sourceImage, c_double(angle), c_double(xCenter), c_double(yCenter), destImage); return destImage
	def CopyRect(f, sourceImage, x1, y1, x2, y2, destImage): f(sourceImage, c_int(x1), c_int(y1), c_int(x2), c_int(y2), destImage); return destImage
	def CopyRectReplicateBorder(f, sourceImage, x1, y1, x2, y2, destImage): f(sourceImage, c_int(x1), c_int(y1), c_int(x2), c_int(y2), destImage); return destImage
	def MirrorImage(f, image, useVerticalMirroringInsteadOfHorizontal=False): f(image, c_bool(useVerticalMirroringInsteadOfHorizontal)); return image
	# Image.width
	def GetImageWidth(f, image): i = c_int(); f(image, byref(i)); return i.value
	# Image.height
	def GetImageHeight(f, image): i = c_int(); f(image, byref(i)); return i.value
	def GetImageData(f, image):
		buf, width, height, scanLine, colorMode = POINTER(c_ubyte)(), c_int(), c_int(), c_int(), c_int()
		f(image, byref(buf), byref(width), byref(height), byref(scanLine), byref(colorMode))
		buf.width, buf.height, buf.scanLine, buf.colorMode = width.value, height.value, scanLine.value, colorMode.value
		return buf

	##### Matching (available in Image class) #####
	def GetFaceTemplate(f, image): faceTemplate = FaceTemplate(); f(image, byref(faceTemplate)); return faceTemplate
	def GetFaceTemplateInRegion(f, image, facePosition): faceTemplate = FaceTemplate(); f(image, byref(facePosition), byref(faceTemplate)); return faceTemplate
	def GetFaceTemplateUsingFeatures(f, image, facialFeatures): faceTemplate = FaceTemplate(); f(image, facialFeatures, byref(faceTemplate)); return faceTemplate
	def GetFaceTemplateUsingEyes(f, image, eyeCoords): faceTemplate = FaceTemplate(); f(image, eyeCoords, byref(faceTemplate)); return faceTemplate
	# the function is available in FaceTemplate class as Match (and MatchFaces also) with a single template argument
	def MatchFaces(f, faceTemplate1, faceTemplate2): similarity = c_float(); f(faceTemplate1, faceTemplate2, byref(similarity)); return similarity.value
	def GetMatchingThresholdAtFAR(f, FARValue): threshold = c_float(); f(c_float(FARValue), byref(threshold)); return threshold.value
	def GetMatchingThresholdAtFRR(f, FRRValue): threshold = c_float(); f(c_float(FRRValue), byref(threshold)); return threshold.value

	##### Webcam usage #####
	def InitializeCapturing(f): f()
	def FinalizeCapturing(f): f()
	def SetHTTPProxy(f, serverNameOrIPAddress, port, userName, password):
		f(cstr(serverNameOrIPAddress), c_ushort(port), cstr(userName), cstr(password))
	def OpenIPVideoCamera(f, compression, URL, userName, password, timeoutSeconds): # compression type example: const.FSDK_MJPEG
		cam = Camera(); f(c_int(compression), cstr(URL), cstr(userName), cstr(password), c_int(timeoutSeconds), byref(cam)); return cam
	# the function available in Camera class as destructor 
	def CloseVideoCamera(f, camera):
		if camera.handle != -1: f(camera); camera.handle = -1
	# the function is available in Camera class (Camera.GrabFrame())
	def GrabFrame(f, camera): im = Image(-1); f(camera, byref(im)); return im
	if windows or linux:
		def SetCameraNaming(f, useDevicePathAsName): f(c_bool(useDevicePathAsName))
		class CameraName(str):
			def __new__(cls, name, devicePath): inst = super(FSDK.CameraName, cls).__new__(cls, name); inst.devicePath = devicePath; return inst
		def ListCameraNames(self): 
			nl, pl = POINTER(camera_char_p)(), POINTER(camera_char_p)()
			n = self._GetCameraListEx(nl, pl)
			lst = [FSDK.CameraName(process_str(name), process_str(devicePath)) for name, devicePath in zip(nl[:n], pl[:n])]
			self._FreeCameraList(nl, n)
			return lst
		def _GetCameraList(f, nameList): n = c_int(); f(byref(nameList), byref(n)); return n.value
		def _GetCameraListEx(f, nameList, pathList): n = c_int(); f(byref(nameList), byref(pathList), byref(n)); return n.value
		def _FreeCameraList(f, cameraList, cameraCount): f(cameraList, cameraCount)

		def ListVideoFormats(self, cameraName):
			vfl = POINTER(VideoFormatInfo)()
			lst = [VideoFormatInfo(f.Width, f.Height, f.FormatIndex) for f in vfl[:self._GetVideoFormatList(cameraName, vfl)]]
			self._FreeVideoFormatList(vfl)
			return lst
		def _GetVideoFormatList(f, cameraName, videoFormatList): cnt = c_int(); f(create_camera_buffer(cameraName), byref(videoFormatList), byref(cnt)); return cnt.value
		def _FreeVideoFormatList(f, videoFormatList): f(videoFormatList)

		def SetVideoFormat(f, cameraName, videoFormat): f(create_camera_buffer(cameraName), videoFormat)
		# the function is available in Camera class as constructor and 'Open' function
		def OpenVideoCamera(f, cameraName): c = Camera(); f(create_camera_buffer(cameraName), byref(c)); return c

	##### Tracker functions (available in Tracker class) #####
	def CreateTracker(f): tr = Tracker(-1); f(byref(tr)); return tr
	def FreeTracker(f, tracker):
		if tracker.handle != -1: f(tracker); tracker.handle = -1
	def ClearTracker(f, tracker): f(tracker)
	def SetTrackerParameter(f, tracker, parameterName, parameterValue):
		f(tracker, cstr(parameterName), cstr(value_to_str(parameterValue)), err_desc = lambda: "%s = %s" % (parameterName, parameterValue))
	def SetTrackerMultipleParameters(f, tracker, parameters):
		err_pos = c_int(); f(tracker, cstr(parameters), byref(err_pos), err_desc = lambda: "in line %s at position %s" % (parameters, err_pos.value))
	def GetTrackerParameter(f, tracker, parameterName):
		return FSDK_Class._receive_string(lambda buf: f(tracker, cstr(parameterName), buf, c_longlong(len(buf)), 
			err_desc = lambda: "parameterName = %s" % parameterName))
	def FeedFrame(self, tracker, cameraIdx, image, maxIDs = 256):
		buf, faceCount = (c_longlong*maxIDs)(), c_longlong()
		self._FeedFrame(tracker, c_longlong(cameraIdx), image, byref(faceCount), buf, c_longlong(maxIDs*8))
		return buf[:faceCount.value]
	def _FeedFrame(f, tracker, cameraIdx, image, faceCount, IDs, maxSizeInBytes): f(tracker, cameraIdx, image, faceCount, IDs, maxSizeInBytes)
	def GetTrackerEyes(f, tracker, cameraIdx, ID): eyes=Eyes(); f(tracker, c_longlong(cameraIdx), c_longlong(ID), byref(eyes)); return eyes
	def GetTrackerFacialFeatures(f, tracker, cameraIdx, ID): ff = Features(); f(tracker, c_longlong(cameraIdx), c_longlong(ID), byref(ff)); return ff
	def GetTrackerFacePosition(f, tracker, cameraIdx, ID): fp = FacePosition(); f(tracker, c_longlong(cameraIdx), c_longlong(ID), byref(fp)); return fp
	def GetTrackerFacialAttribute(f, tracker, cameraIdx, ID, attributeName):
		return FSDK_Class._receive_string(lambda buf: f(tracker, c_longlong(cameraIdx), c_longlong(ID), cstr(attributeName), buf, c_longlong(len(buf)),
			err_desc = lambda: "ID = %s, attributeName = %s" % (ID, attributeName)))
	def LockID(f, tracker, ID): f(tracker, c_longlong(ID))
	def UnlockID(f, tracker, ID): f(tracker, c_longlong(ID))
	def PurgeID(f, tracker, ID): f(tracker, c_longlong(ID))
	def GetName(f, tracker, ID): return FSDK_Class._receive_string(lambda buf: f(tracker, c_longlong(ID), buf, c_longlong(len(buf))))
	def SetName(f, tracker, ID, name): f(tracker, c_longlong(ID), cstr(name))
	def GetIDReassignment(f, tracker, ID): rID = c_longlong(); f(tracker, c_longlong(ID), byref(rID)); return rID.value
	def GetSimilarIDList(f, tracker, ID):
		lst = (c_longlong*FSDK.GetSimilarIDCount(tracker, ID))()
		f(tracker, ID, lst, c_longlong(len(lst)*8))
		return lst
	def GetSimilarIDCount(f, tracker, ID): count = c_longlong(); f(tracker, c_longlong(ID), byref(count)); return count.value
	def GetAllNames(f, tracker, ID):
		return FSDK_Class._receive_string(lambda buf: f(tracker, ID, buf, c_longlong(len(buf)))).split(';')
	def SaveTrackerMemoryToFile(f, tracker, fileName): f(tracker, cstr(fileName), err_desc = fileName)
	def LoadTrackerMemoryFromFile(f, fileName): tr = Tracker(-1); f(byref(tr), cstr(fileName), err_desc = fileName); return tr
	if True: ### use Tracker.GetMemory() instead of the following two functions
		def _GetTrackerMemoryBufferSize(f, tracker): i = c_longlong(); f(tracker, byref(i)); return i.value
		def _SaveTrackerMemoryToBuffer(f, tracker, buffer): f(tracker, buffer, c_longlong(len(buffer)))
	def LoadTrackerMemoryFromBuffer(f, buffer): tr = Tracker(-1); f(byref(tr), buffer); return tr

	##### Facial attributes #####
	def DetectFacialAttributeUsingFeatures(f, image, facialFeatures, attributeName):
		return FSDK_Class._receive_string(lambda buf: f(image, facialFeatures, cstr(attributeName), buf, c_longlong(len(buf)))) # should we convert the string values into the dict ?
	def GetValueConfidence(f, attributeValues, value): conf = c_float(); f(cstr(attributeValues), cstr(value), byref(conf)); return conf.value

	@FSDK_ver("7.2")
	def SetParameters(f, values='', **kwargs):
		err_pos, parameters = c_int(), values.strip(';\n\t ')
		def chain():
			if parameters: yield parameters
			for n, v in kwargs.items(): yield ('%s=%s' % (n, value_to_str(v)))
		parameters = ';'.join(chain())
		f(cstr(parameters), byref(err_pos), err_desc = lambda: "in line %s at position %s" % (parameters, err_pos.value))

	@FSDK_ver("7.2")
	def SetParameter(f, name, value): f(cstr(name), cstr(value_to_str(value)), err_desc = lambda: "%s = %s" % (name, value))

	FSDK_Wrapper.prepare(locals())
	del FSDK_Wrapper.prepare

FSDK = FSDK_Class()
